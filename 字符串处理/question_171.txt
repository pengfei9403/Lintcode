/*
给出一个字符串数组S，找到其中所有的乱序字符串(Anagram)。如果一个字符串是乱序字符串，那么他存在一个字母集合相同，但顺序不同的字符串也在S中。
样例
对于字符串数组 ["lint","intl","inlt","code"]

返回 ["lint","inlt","intl"]

*/


//题目心得：要注意时间负责度的问题。
//string已经重载了小于运算符
//解题思路：对vector创建副本，对副本内元素的内容进行排序，
//排序后对副本再创建副本2，对副本2的元素进行排序，
//上述处理后，满足题目要求的字符串已经相等且相邻
//遍历副本2，找出有重复的部分，与副本1匹配，将想位置的原始vector内容push进ans。


class Solution {
public:    
    /**
     * @param strs: A list of strings
     * @return: A list of strings
     */
    bool anagram(string s, string t) {
        // write your code here
        if(0 == t.size()){
        	return true ;
		}
        if(s == t){
            return true;
        }else{
            return false;
        }
    }
    vector<string> anagrams(vector<string> &strs) {
        // write your code here
        int flag = 0 ;
        vector<int> arr(strs.size()) ;
        vector<string> temp(strs) ;
        vector<string> ans ;
        vector<string>::iterator str=strs.begin();
        int temp_size = temp.size();
        for(int i = 0 ; i < temp_size ; i++){
        	sort(temp[i].begin(),temp[i].end());
		}
		if(0 == temp_size){
			return ans;
		}else if(1 == temp_size){
			return temp;
		}
       	vector<string> temp2(temp);
		sort(temp2.begin(),temp2.end());
		for(int i = 0 ; i < temp_size-1 ; i++){
			if(temp2[i] == temp2[i+1]){
				flag = 1 ;
			}else{
				if(flag){
					flag = 0 ;
					for(int j = 0 ; j < temp_size ; j++){
						if(temp2[i] == temp[j]){
							ans.push_back(strs[j]);
						}
					}
				}
			}
		}
		if(flag){
			flag = 0 ;
			for(int j = 0 ; j < temp_size ; j++){
				if(temp2[temp_size-1] == temp[j]){
					ans.push_back(strs[j]);
				}
			}
		}
		return ans ;
    }
};